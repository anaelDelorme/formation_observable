---
title: "Mise à jour du site"
toc-depth: 4
---

## Ajouter une page

Nous allons ajouter une page sur l'historique météorologique en Occitanie. Pour cela nous créons un fichier **meteo_occitanie.md** dans le répertoire `src`.

Vous pouvez mettre le code suivant : 

````
# Météo en Occitanie

```{js}
display(1 + 2);

``` 
````

Ce qui affichera : 

![](img/create_page.png)

:::callout-note
Si votre codespaces n'est plus actif, veuillez le relancer. Et pour relancer le site en dev, tapez dans la console : `npm run dev` dans le répertoire `hello-framework`
:::

Vous avez pu le constater, la création de pages est très facile ! Et vous avez également constater que le fichier créé était en `.md`. C'est un markdown, que l'on connait déjà dans Rmarkdown ou dans Quarto.

Pour en savoir plus sur le markdown en Observable : [Markdown en observable](aller_plus_loin.qmd) 

## Chargement de données

Je vous propose de travailler sur les données de météofrance pour les départements d'Occitanie en 2023 et 2024. Vous trouverez les données sur Github : <https://github.com/anaelDelorme/observable_formation_SSP/blob/main/formation/src/data/>. Pour télécharger les données, ilfaut cliquer sur le fichier puis cliquer sur le bouton `download raw`.        

Pour commencer, télécharger uniquement les données pour la Haute-Garonne.        

Puis déposer le fichier dans votre site observable : `src/data/`.   

Dans le fichier meteo.md, nous allons charger les données. Pour cela nous utilisons la fonction `FileAttachment`. Cette fonction est chargée par défaut. Elle propose plusieurs méthodes (par exemple) :     

-   file.csv     
-   file.xlsx    
-   file.text     
-   file.json    
-   file.parquet     
-   file.arrow    
-   ...     

Nous avons récupéré un fichier csv. Nous pouvons donc mettre à jour meteo.md en indiquant :


````
```js
// Import des données
const meteo_31_2023_2024 = FileAttachment("data/Q_31_latest-2023-2024_RR-T-Vent.csv").csv()
```
````

Cela crée une constante (dans notre cas c'est un tableau) qui s'appelle `meteo_31_2023_2024`. En indiquant `js`, je dis que le code sera du javascript (js). Si je veux afficher le code sur ma page web, il faut que je mette `js echo`.   


:::{.callout-important}
En JavaScript, une **const** est un mot-clé utilisé pour déclarer une variable dont la valeur est constante, c'est-à-dire qu'elle ne peut pas être réaffectée (ré-assignée) après sa déclaration initiale.   

Une fois déclarée avec const, la valeur de la variable ne peut pas être modifiée. Toute tentative de réaffecter une nouvelle valeur à cette variable générera une erreur.
:::

:::{.callout-warning}
Si vous essayer de voir les données en faisant un `display(meteo_31_2023_2024)` (équivalent à un `print()` en R) dans le bloc js d'import, vous verrez que l'objet est un **Promise**. Une Promise en JavaScript est une fonctionnalité qui permet de gérer les opérations asynchrones, c'est-à-dire des tâches qui prennent du temps à s'exécuter et dont le résultat n'est pas immédiatement disponible. C'est une sorte de promesse qui représente une valeur potentielle qui peut être résolue (avec succès) ou rejetée (en cas d'erreur).    

Vous ne pouvez pas accéder aux données de `meteo_31_2023_2024` dans ce bloc. Mais Observable est sympa : il *résous* automatiquement les promises dans les autres blocs. Ainsi si vous créez un autre bloc `js` et que vous mettez `display(meteo_31_2023_2024)`, alors il affichera les données du **Promise**.

Plus d'infos : <https://observablehq.com/framework/reactivity#promises>
:::

## Affichage des données

Je souhaite afficher les données. Mais Javascript ne permet pas un accès très simple aux données. Je vous propose de faire une fonction pour extraire, typer et renommer les données. Pour cela, vous pouvez insérer le bloc de code suivant : 

````
```js
function extractProperties(obj) {
  const properties = obj["NUM_POSTE;NOM_USUEL;LAT;LON;ALTI;AAAAMMJJ;RR;QRR;TN;QTN;HTN;QHTN;TX;QTX;HTX;QHTX;TM;QTM;TNTXM;QTNTXM;TAMPLI;QTAMPLI;TNSOL;QTNSOL;TN50;QTN50;DG;QDG;FFM;QFFM;FF2M;QFF2M;FXY;QFXY;DXY;QDXY;HXY;QHXY;FXI;QFXI;DXI;QDXI;HXI;QHXI;FXI2;QFXI2;DXI2;QDXI2;HXI2;QHXI2;FXI3S;QFXI3S;DXI3S;QDXI3S;HXI3S;QHXI3S"].split(";");
  
  // Fonction pour vérifier si une valeur est numérique
  function isNumeric(value) {
    return !isNaN(value) && isFinite(value);
  }

  // Convertir les valeurs en nombres si elles sont numériques
  const precipitation = isNumeric(properties[6]) ? Number(properties[6]) : null;
  const temp_min = isNumeric(properties[8]) ? Number(properties[8]) : null;
  const temp_max = isNumeric(properties[12]) ? Number(properties[12]) : null;
  const ampli_thermique = isNumeric(properties[20]) ? Number(properties[20]) : null;
  const duree_gel_minute = isNumeric(properties[26]) ? Number(properties[26]) : null;

// Fonction pour transformer le champ date
  function convertToDate(aaaammjj) {
  
  if (/^\d{8}$/.test(aaaammjj)) {
    const year = aaaammjj.substring(0, 4);
    const month = aaaammjj.substring(4, 6);
    const day = aaaammjj.substring(6, 8);

    // Créer un nouvel objet Date
    return new Date(`${year}-${month}-${day}`);
  } else {
    throw new Error('La chaîne doit être au format AAAAMMJJ');
  }
}

const dateformatee = convertToDate(properties[5]);

  return {
    id_poste: properties[0], 
    nom_poste: properties[1], 
    lat: properties[2], 
    lon: properties[3], 
    date: dateformatee,
    precipitation: precipitation,
    temp_min: temp_min,
    temp_max: temp_max,
    ampli_thermique: ampli_thermique,
    duree_gel_minute: duree_gel_minute
  };
}
const meteo_31_2023_2024_extrait = meteo_31_2023_2024.map(extractProperties);
display(meteo_31_2023_2024_extrait);

```
````

J'aimerais maintenant afficher une phrase qui m'indique les températures max et min pour un lieu et une date donnée. Pour cela je vais créer un bloc de code en javascript pour récupérer les données :


````
```js
// Options pour le formatage de la date
const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
const nom_poste_recherche = "ARBAS";
const date_recherche = new Date("2023-05-21");
// Conversion de l'objet Date en chaîne de caractères au format souhaité
const dateString = date_recherche.toLocaleDateString('fr-FR', options).split('/').join('-');

const objetTrouve = meteo_31_2023_2024_extrait.find(
  obj => obj.nom_poste === nom_poste_recherche && obj.date.getTime() === date_recherche.getTime()
);
display(objetTrouve)

```
````
:::{.callout-warning}
En Javascript les données au format date ne peuvent pas être comparées via un `===`. Pour les comparer il faut utilser la fonction getTime() : `date1.getTime() === date2.getTime()`.
:::

Puis j'écris une phrase directement en markdown en faisant référence aux données grâce au caractère **$**. Par exemple : 
Les températures minimale et maximale pour la station ${nom_poste_recherche} à la date du ${dateFormatee} sont ${objetTrouve.temp_min}°C et ${objetTrouve.temp_max}°C.



:::

## Création d'un tableau

Je souhaite afficher un tableau avec les données que je viens de charger. Pour cela je peux très simplement utiliser la fonction `Inputs.table()` d'Observable.


````
```js
// Création d'une table d'affichage de mes données
Inputs.table(meteo_31_2023_2024_extrait)
```
````

Il est possible de faire un tableau plus joli en jouant sur les paramètres d'Inputs.table et du code html. Voici un exemple que vous pouvez tester :   

````
```js
// Trouver la valeur maximale des précipitations
const maxPrecipitation = Math.max(...meteo_31_2023_2024_extrait.map(d => d.precipitation));
display(maxPrecipitation)
// Création d'une table d'affichage avec mise en forme
display(Inputs.table(meteo_31_2023_2024_extrait,
    {
      columns: [
        "nom_poste",
        "date",
        "temp_min",
        "temp_max",
        "precipitation"
      ],
      header: {
        nom_poste: "Poste météo",
        date: "Date",
        temp_min: "Température min. (°C)",
        temp_max: "Température max. (°C)",
        precipitation: "Précipitation (mm)"
      },
      format: {
          nom_poste: (x) => x.charAt(0).toUpperCase() + x.slice(1).toLowerCase(),
          date: (x) => x.toLocaleDateString('fr-FR', options).split('/').join('-'),
          temp_min: (x) => {
            const temp = x.toFixed(1);
            if (x > 25) {
              return html`<span style="color: green;">${temp}</span>`; // Vert si supérieur à 25
            } else if (x < 0) {
              return html`<span style="color: red;">${temp}</span>`; // Rouge si négatif
            } else {
              return temp; // Aucune couleur si entre 0 et 25
            }
          },
          temp_max: (x) => {
            const temp = x.toFixed(1);
            if (x > 25) {
              return html`<span style="color: green;">${temp}</span>`; // Vert si supérieur à 25
            } else if (x < 0) {
              return html`<span style="color: red;">${temp}</span>`; // Rouge si négatif
            } else {
              return temp; // Aucune couleur si entre 0 et 25
            }
          },
          precipitation: (x) => {
            const temp = x.toFixed(1);
            const barLength = (x / maxPrecipitation) * 100;
            return html`<div style="
                  background: var(--theme-blue); 
                  color: black;
                  width: ${barLength}%; 
                  height: 20px;
                  float: right;
                  padding-right: 3px;
                  box-sizing: border-box;
                  overflow: visible;
                  display: flex;
                  justify-content: end;">
                    ${temp}
                  </div>`;
          }
        }
    })
)
```

````

En savoir plus sur les Inputs.table : <https://observablehq.com/framework/inputs/table>

## Création d'un graphique

## Affichage d'une carte (map)

## Zones de sélection / formulaires

## Mise en forme


### Carte (card)

Observable utilise des cartes pour grouper et délimiter du contenu. Pour créer une carte, il suffit d'utiliser la balise div avec la class *card* :

````
<div class="card">
````

### Grille

Une grille va contenir des cartes. Il est possible d'indiquer le nombre de colonnes de la page. Par exemple, si on veut 4 colonnes : 

````
<div class="grid grid-cols-4">
  <div class="card"><h1>A</h1></div>
  <div class="card"><h1>B</h1></div>
  <div class="card"><h1>C</h1></div>
  <div class="card"><h1>D</h1></div>
</div>
````

Les possibilités sont *grid-cols-2*, *grid-cols-3*, ou *grid-cols-4*.       
Voir les différentes possibilités de grille : <https://observablehq.com/framework/markdown#grids>

::::callout-note
Retravailler votre page de météo pour mettre les items dans des cartes et définissez une grille d'affichage.
::::

### Thème

Il est possible d'appliquer des thèmes. Pour cela il faut mettre à jour l'entête du fichier `.md` en ajoutant : `theme: "glacier"` ou `theme: [cotton, slate]`

Voir le détail des thèmes ici : <https://observablehq.com/framework/themes>. 

### Texte en couleur

Vous pouvez écrire du texte en couleur, via une balise Html :     

-  `<div class="red">Ce texte est en rouge.</div>`
-  `<div class="yellow">Ce texte est en jaune.</div>`
-  `<div class="green">Ce texte est en vert.</div>`
-  `<div class="blue">Ce texte est en bleu.</div>`
-  `<div class="muted">Ce texte est en gris clair.</div>`


### Création de blocs mis en valeur : 
 
On peut ajouter des blocs de *note*, *tip*, *warning* et *caution* : 

````
<div class="note" label="Note">C'est une note.</div>
<div class="tip" label="Astuce">C'est une astuce.</div>
<div class="warning" label="⚠️ Danger ⚠️">C'est une attention.</div>
<div class="caution" label>C'est une mise en garde.</div>

````



<button type="button" class="btn btn-primary btn-lg">

<a href="deploiement_projet.qmd">Suivant</a>

</button>
